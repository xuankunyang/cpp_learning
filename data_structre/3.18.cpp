#include <iostream>

using namespace std;

int main()
{
	// 顺序结构的队列  front rear 分别指向队首和队尾的下一位 一实一虚-> 为了区别empty（）和full（）
	// 很有意思的是顺序结构为了减少时空复杂度 顺序队列形成了一个环
	// 进出队列都是o（1）
	// 
	// 其实比较优化的是链式结构
	// 进出队列都是o(1)
	// 链式队列 描述子 front指针和rear指针  直接指向队首和队尾元素
	//
	// 优先队列 priority_queue 堆
	// 
	// 
	// 树
	// 度在树中 指的是子节点的数量
	// 
	// 二叉树
	// 满二叉树 除了叶子节点都有两个儿子
	// 完全二叉树： 自右向左 缺少一些叶子
	// 二叉树的性质：
	// 1  非空二叉树上 第i层最多有 2^(i-1)个节点
	// 2  一棵高度为k的二叉树最多有 2^k -1 个节点
	// 3  对于一个非空二叉树 叶子节点个数n0  度数为2的节点个数为n2 则有n0=n2+1
	//proof：
	// n=n0+n1+n2
	// n-1=0*n0+1*n1+2*n2
	// 得到n0=n2+1
	// 
	// 4  完全二叉树中 ：高度 k=[log2(n)]+1
	// 5  完全二叉树中 ：节点i 父节点编号为[i/2] 如果2i>n 节点i无左儿子 否则左儿子编号为2i 同理用2i+1讨论右儿子
	// 
	// 储存一棵完全二叉树 可以省略 ls rs 和fa  考虑下标之间的关系
	// 考虑上面的性质 如果一棵树非常接近完全二叉树 那么可以将其补充为完全二叉树（添加虚节点）
	// 
	// 另一种思路 ： 二叉链表 （标准形式）
	// node 定义为 left data right
	// 
	// 广义标准形式 node加入了fa
	// 
	// 
	// 
	// 
	//

	return 0;
}