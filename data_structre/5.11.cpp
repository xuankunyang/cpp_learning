#include <iostream>
using namespace std;

int main()
{
	ios::sync_with_stdio(false), cin.tie(0), cout.tie(0);
	//
	// B+树，允许存在重复的关键字
	// B+树存在索引节点和数据节点，数据节点在索引层中叶子节点的下一层
	// 非叶子的根节点至少有两个、至多有M个孩子
	// 除了根节点外，每个索引节点至少有 （M/2）上取整 至多有M个孩子
	// M通常远大于L（叶子节点数量）
	// 
	// 
	// 哈希查找：
	// 直接利用数组的下标，若数据（int）存在，则将该下标对应的数据设为1，否则为1，称为哈希表
	// 上面是最基础的一种映射
	// 以一个可以存储m个数据的连续存储空间（数组），存储n个关键字 负载因子、负载系数：\partial = \frac{m}{n}
	// 一些常用的哈希函数：
	// 1、直接寻址：H(key)=a*key+b
	// 2、除留余数：H(key)=key mod p 特别注意，这里的p因取大于n的最小素数，尽量减少空间的规律性浪费
	// 3、数据分析
	// 4、平方取中：若关键字分布不均匀，将其平方，取其中间的几位，有时可能就会很均匀
	// 5、折叠
	// 
	// 冲突的解决：
	// 线性探测法：当两个关键字（两个相同关键字只存一次）映射到同一个值的时候，就往后探测一位，注意先来后到
	// 二次探测法：(H(key)+or-i^2)%m,闭哈希表
	// 链地址法：直接利用首席插入，链式查找
	// 
	// 哈希表的删除：
	// 删除的标记：2
	// 不能直接赋值为0，有可能该数据被挤到别的地方了
	// O（1）
	// 
	// 由此可以引出哈希排序
	// 
	// 
	// 
	// 排序：
	// 稳定排序：a和b等大，若原数组中a在b之前，排序完后，a仍然在b之前
	// 内排序：
	// 冒泡排序：别漏了flag，效率最好O（n）->已排好序，最差O（n^2）->直接逆序，是稳定排序
	// 稳定性的本质：相邻元素的交换是可以保证文稳定性的，非相邻元素的交换，中间元素未知，稳定性很难保证
	// 冒泡中的双重循环，可以改为递归，效率大概率会赶不上循环
	// 
	// 插入排序：
	// 
	// 
	// 
	// 
	//

	return 0;
}