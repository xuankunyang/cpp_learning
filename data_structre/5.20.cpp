#include <iostream>
using namespace std;

int main()
{
	ios::sync_with_stdio(false), cin.tie(0), cout.tie(0);

	//K路归并：
	// 随着归并的有序段变长，归并的次数会下降
	// 归并长度k，有序段总个数m，趟数：logk(m)
	// k路归并，至少需要2k个存储区
	// 
	//多阶段归并：
	// 有2k个存储区，能进行2k-1路归并
	// 每次归并的时候，归并数量，应为各个磁盘中长度的最小值
	// 利用斐波那契的性质，一次一次递归下去，当总数量不是一个斐波那契数的时候，选比他大的那个斐波那契数，添加一些虚段
	// 
	//置换选择：
	// 通过拉长每个有序序列的长度来减少初始归并段的长度
	// 
	//最佳归并树：
	// 类似哈夫曼树的构造
	// 
	//哈希排序：
	// 将值映射到相应的地址上（应已知值的范围），接着进行一次遍历，时间复杂度O(n)
	//  
	// 
	// 
	//图：
	// 树中讨论的度，指的是孩子的数量，和图中讨论的度不同
	// 
	// 
	//










	return 0;
}